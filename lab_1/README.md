**Открытая вершина** -- у неё нет потомков

Вводятся два флага: 
1. флаг потомков (j) = результат работы метода потомков (т.е. нашли куда идти дальше или нет)
2. флаг решения (y) -- 1 не найдено, 0 найдено


Алгоритм работы программы можно разделить на несколько ключевых этапов, каждый из которых выполняет определённые задачи. Программа реализует графы и проводит поиск в них с использованием методов BFS (поиск в ширину) и DFS (поиск в глубину), а также визуализирует графы. Рассмотрим алгоритм подробнее:

### 1. Определение структуры
Основные классы, которые используются в программе:
- **Node**: Представляет узел графа. Хранит номер узла.
- **Edge**: Представляет рёбер графа. Хранит информацию о начальном и конечном узлах, а также весе рёбра.
- **Graph**: Основной класс, который управляет рёбрами и узлами графа, а также реализует алгоритмы поиска.

### 2. Генерация рёбер графа
Класс `Example` определяет два метода `edgeLst_1` и `edgeLst_2`, которые возвращают набор рёбер, формирующих граф. Эти рёбра используются для создания экземпляра класса `Graph`.

### 3. Визуализация графа
Функция `visualize_graph` принимает список рёбер и создает визуализацию графа с помощью библиотеки NetworkX, а затем сохраняет изображение в формате PNG. Узлы графа отображаются с подписями, а рёбра — с указанием их весов.

### 4. Поиск по графу
#### a. Поиск в глубину (DFS)
- Метод `dfs` и его вспомогательный метод `__dfs__sample_search` обрабатывают поиск в глубину.
- Узлы хранятся в стеке (`Stack`).
- Поиск продолжается, пока не достигнут целевой узел или пока не будут исчерпаны все возможные пути.
- В случае успеха, возвращается путь от стартового узла к целевому.

#### b. Поиск в ширину (BFS)
- Метод `bfs` и вспомогательный метод `__bfs_sample_search` реализуют поиск в ширину.
- Узлы хранятся в очереди (`Queue`).
- Алгоритм исследует узлы на уровне, прежде чем переходить к узлам следующего уровня.
- Как и в DFS, в случае нахождения пути результат возвращается, иначе — `None`.

### 5. Главный блок программы
В основном блоке (под `if __name__ == "__main__":`) происходит:
- Вывод сообщения о начале работы программы.
- Создание графа на основе второго набора рёбер.
- Визуализация графа с использованием функции `visualize_graph`.
- Выполнение поиска в глубину от узла 0 к 7 с выводом результата пути.
- Выполнение поиска в ширину от узла 0 к 7 с выводом результата пути через вспомогательную функцию `show`.

### Подведение итогов
Программа эффективно управляет графами, обеспечивая пользователям возможность визуализировать граф и находить пути с использованием распространённых алгоритмов поиска. Пользуясь классами и методами, разработчик может легко модифицировать и расширять функционал по мере необходимости.

Давайте подробно разберем алгоритмы BFS (поиск в ширину) и DFS (поиск в глубину), представленные в приведенном вами коде. Мы рассмотрим их реализацию, основные шаги и структуру.

### 1. Поиск в ширину (BFS)

#### Описание
BFS — это алгоритм, который использует очередь для обхода графа. Он помимо прочего отлично подходит для поиска кратчайшего пути в невесомом графе, поскольку сначала посещает узлы ближе к стартовой точке.

#### Основные шаги в `bfs`:
1. **Инициализация**:
   - Создаем очередь `self.opened`, в которой будем хранить узлы для обработки.
   - Устанавливаем `self.goal` в целевой узел.
   - Добавляем стартовый узел в очередь.

2. **Обработка узлов** в цикле:
   - Пока есть узлы в очереди и решение не найдено (`self.isSolutionNotFound`):
     - Печатаем текущее состояние очереди.
     - Вызываем `__bfs_sample_search()`, который добавляет соседние узлы в очередь.
     - Проверяем, найдено ли решение (устанавливаем флаг `self.isSolutionNotFound`).

3. **Извлечение узлов**:
   - Извлекаем текущий узел из очереди и добавляем его в список посещенных (`self.closed`).
   - Если очередь не пуста, продолжаем обработку.

4. **Возврат результата**:
   - Если узел не найден, возвращаем `None`. В противном случае вызываем метод `__get_res_pwd(start)`, который восстанавливает путь от стартового узла до целевого.

#### `__bfs_sample_search()`:
- Проходит по всем рёбрам графа, чтобы найти соседние узлы текущего узла.
- Если узел не был посещён и не был добавлен в очередь, он добавляется в очередь, помечается как использованный и обновляется путь.

### 2. Поиск в глубину (DFS)

#### Описание
DFS использует стек (или рекурсию) для глубокого обхода графа, что позволяет исследовать максимально возможные ветви до тех пор, пока не достигнем целевого узла или не исчерпаем все узлы.

#### Основные шаги в `dfs`:
1. **Инициализация**:
   - Создаем стек `self.opened`, добавляем стартовый узел.

2. **Обработка узлов** в цикле:
   - Аналогично BFS, пока есть узлы в стеке и решение не найдено:
     - Печатаем текущее состояние стека.
     - Вызываем `__dfs__sample_search()` для обработки узлов.
     - Проверяем найдено ли решение.

3. **Извлечение узлов**:
   - Если нет потомков (`self.childCounter == 0`), извлекаем узел из стека и добавляем его в список посещённых.

4. **Возврат результата**:
   - Если узел не найден, возвращаем `None`. Иначе, просто возвращаем стек, который пока что не обработан.

#### `__dfs__sample_search()`:
- Как и в BFS, проверяет соседние узлы.
- Если узел не был посещён и рёбра ещё не использованы, добавляет его в стек и помечает как использованный.

### Заключение
Оба алгоритма работают с графами, используя различные структуры данных (очередь для BFS и стек для DFS). Они оба используют механизмы пометки узлов как посещённых и восстанавливают путь к целевому узлу. Разница заключается в том, как они выбирают узлы для обработки: BFS — по уровням, DFS — по глубине, что может привести к различным результатам в зависимости от структуры графа.

Давайте подробно разберем алгоритмы BFS (поиск в ширину) и DFS (поиск в глубину), представленные в приведенном вами коде. Мы рассмотрим их реализацию, основные шаги и структуру.

### 1. Поиск в ширину (BFS)

#### Описание
BFS — это алгоритм, который использует очередь для обхода графа. Он помимо прочего отлично подходит для поиска кратчайшего пути в невесомом графе, поскольку сначала посещает узлы ближе к стартовой точке.

#### Основные шаги в `bfs`:
1. **Инициализация**:
   - Создаем очередь `self.opened`, в которой будем хранить узлы для обработки.
   - Устанавливаем `self.goal` в целевой узел.
   - Добавляем стартовый узел в очередь.

2. **Обработка узлов** в цикле:
   - Пока есть узлы в очереди и решение не найдено (`self.isSolutionNotFound`):
     - Печатаем текущее состояние очереди.
     - Вызываем `__bfs_sample_search()`, который добавляет соседние узлы в очередь.
     - Проверяем, найдено ли решение (устанавливаем флаг `self.isSolutionNotFound`).

3. **Извлечение узлов**:
   - Извлекаем текущий узел из очереди и добавляем его в список посещенных (`self.closed`).
   - Если очередь не пуста, продолжаем обработку.

4. **Возврат результата**:
   - Если узел не найден, возвращаем `None`. В противном случае вызываем метод `__get_res_pwd(start)`, который восстанавливает путь от стартового узла до целевого.

#### `__bfs_sample_search()`:
- Проходит по всем рёбрам графа, чтобы найти соседние узлы текущего узла.
- Если узел не был посещён и не был добавлен в очередь, он добавляется в очередь, помечается как использованный и обновляется путь.

### 2. Поиск в глубину (DFS)

#### Описание
DFS использует стек (или рекурсию) для глубокого обхода графа, что позволяет исследовать максимально возможные ветви до тех пор, пока не достигнем целевого узла или не исчерпаем все узлы.

#### Основные шаги в `dfs`:
1. **Инициализация**:
   - Создаем стек `self.opened`, добавляем стартовый узел.

2. **Обработка узлов** в цикле:
   - Аналогично BFS, пока есть узлы в стеке и решение не найдено:
     - Печатаем текущее состояние стека.
     - Вызываем `__dfs__sample_search()` для обработки узлов.
     - Проверяем найдено ли решение.

3. **Извлечение узлов**:
   - Если нет потомков (`self.childCounter == 0`), извлекаем узел из стека и добавляем его в список посещённых.

4. **Возврат результата**:
   - Если узел не найден, возвращаем `None`. Иначе, просто возвращаем стек, который пока что не обработан.

#### `__dfs__sample_search()`:
- Как и в BFS, проверяет соседние узлы.
- Если узел не был посещён и рёбра ещё не использованы, добавляет его в стек и помечает как использованный.

### Заключение
Оба алгоритма работают с графами, используя различные структуры данных (очередь для BFS и стек для DFS). Они оба используют механизмы пометки узлов как посещённых и восстанавливают путь к целевому узлу. Разница заключается в том, как они выбирают узлы для обработки: BFS — по уровням, DFS — по глубине, что может привести к различным результатам в зависимости от структуры графа.


Поиск в ширину (BFS) и поиск в глубину (DFS) — два основных алгоритма обхода графов, и между ними есть несколько ключевых отличий:

### 1. Структура данных
- **BFS** использует **очередь**. Узлы добавляются в очередь по мере их открытия, и обрабатываются в порядке их добавления (первый пришёл — первый вышел).
- **DFS** использует **стек**. Он может быть реализован с помощью рекурсии или явного стека. Узлы добавляются в стек, и обрабатываются в порядке, последний пришёл — первый вышел.

### 2. Порядок обработки узлов
- **BFS** обходится «слоями», начиная с узлов на первом уровне (ближайших к стартовому узлу), затем переходит ко второму уровню, и так далее. Это позволяет находить кратчайший путь в неориентированных графах без весов.
- **DFS** углубляется в граф, пока возможно, прежде чем вернуться назад. Он сначала исследует все дочерние узлы от текущего узла перед тем, как перейти к следующему.

### 3. Хранение узлов
- **BFS** хранит все узлы текущего уровня в очереди, что может потребовать значительного объёма памяти, особенно в широких графах.
- **DFS** хранит только узлы на текущем пути, что обычно требует меньше памяти, но при этом может привести к необходимости хранения больших стеков.

### 4. Применение
- **BFS** часто используется для поиска кратчайших путей и в задачах, где важен первый найденный ответ.
- **DFS** применяется в задачах, где необходимо исследовать все возможные пути, как, например, в задачах на разбиение, комбинаторных поисках и т.д.

### 5. Сложность
- Оба алгоритма имеют временную сложность O(V + E), где V — количество вершин, а E — количество рёбер, однако различается использование памяти.

### 6. Условия завершения
- В случае **BFS** процесс обычно завершается, когда найден целевой узел на самом низком уровне, в то время как **DFS** может завершиться, когда все пути будут исследованы, даже если это не оптимальный путь.

### Итог
Выбор между BFS и DFS зависит от конкретной задачи, требований к памяти и необходимости поиска кратчайшего пути.