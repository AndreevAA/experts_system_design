### Алгоритм работы программы

1. **Инициализация среды**
   - Загружается основной модуль программы.
   - Проводится инициализация необходимых библиотек и упаковка.

2. **Создание классов**
   - Определяются классы: `Rule`, `Atom`, `Constant`, `Variable`, `Table`.
   - Каждый класс имеет свои атрибуты и методы, которые позволяют управлять соответствующими данными.

3. **Класс `Constant`**
   - **Инициализация**: Принимает имя и значение константы.
   - **Методы**:
     - `get_value()`: возвращает значение константы.
     - Отдает доступ только для чтения; значение нельзя изменить.

4. **Класс `Variable`**
   - **Инициализация**: Принимает имя переменной и может быть назначено начальное значение.
   - **Методы**:
     - `set_value(value)`: назначает новой переменной новое значение.
     - `get_value()`: возвращает текущее значение переменной.
   - Переменные могут изменяться в процессе выполнения программы.

5. **Класс `Atom`**
   - **Инициализация**: Принимает имя атома и список его терминалов.
   - **Методы**:
     - Методы для добавления, удаления и получения терминалов.

6. **Класс `Rule`**
   - **Инициализация**: Принимает список входных атомов и один выходной атом.
   - **Методы**:
     - `evaluate(input_values)`: применяет правило к переданным значениям, проверяя, соответствуют ли они требованиям.
     - Возвращает выходной атом, если правило было выполнено успешно.

7. **Класс `Table`**
   - **Инициализация**: Пустая таблица подстановок для переменных.
   - **Методы**:
     - `add_variable(variable)`: добавляет переменную в таблицу.
     - `set_value(variable_name, value)`: устанавливает значение для указанной переменной.
     - `get_value(variable_name)`: возвращает текущее значение переменной.
     - `reset()`: сбрасывает все переменные к их начальному состоянию.

8. **Мониторинг и взаимодействие**
   - Программа предоставляет интерфейс для взаимодействия с пользователем, позволяя добавлять новые переменные и правила.
   - При вводе данных пользователем система производит необходимые подстановки и вычисления для нахождения вывода на основании введенных правил и значений.

9. **Вывод результатов**
   - На основе оценивания правил и установленных значений переменных программа формирует итоговые результаты.
   - Вывод результатов может следовать в различных форматах (консольный вывод, файл и т.д.).

### Использование программы

- Пользователь может взаимодействовать с программой, добавляя константы и переменные, создавая правила и получая результаты, основанные на этих правилах.
- Программа поддерживает динамическое изменение входных данных и гибкость в обработке логических связей. 

Этот алгоритм описывает уровень работы программы, от инициализации классов до обработки данных и вывода результатов. Каждый компонент несет свою ответственность и работает в рамках общей логики приложения.

### Описание вывода

1. **Текущая подцель C(W)**
   - Программа пытается доказать подцель \( C(W) \). Это значит, что текущей задачей является доказательство атома \( C \) с аргументом \( W \).

2. **Список доказанных атомов**
   - В этом списке представлены атомы, которые уже были доказаны ранее: 
     - \( O(N, M1) \)
     - \( M(M1) \)
     - \( A(W) \)
     - \( E(N, A1) \)

3. **Список доказанных правил**
   - На данном этапе правил не было доказано (пустой список).

4. **Номер текущего правила**
   - Номер правил, которые используются для выведения текущего атома. Здесь он равен 1, что может означать, что используется первое правило из предварительно определенного набора.

5. **Унификация и таблицы**
   - Процесс унификации показан как успешный: \( C(x) \) унифицируется с \( C(W) \).
   - Следовательно, таблицы подстановок и связей обновляются:
     - **Таблица подстановок**: `{'x': W}` — показывает, что символ `x` заменяется на `W`.
     - **Таблица связей**: `{'W': {'x'}}` — связывает `W` с `x`.

6. **Атом A(x)**
   - Для атома \( A(x) \) программа проверяет на совпадение. 
   - Сообщения "Имена не совпадают" указывают на отсутствие совпадения имен в процессе универсальной унификации.
   - Атом \( A(x) \) уже был доказан, поэтому программа игнорирует его повторное доказательство.

7. **Атом W(y)**
   - Следующий атом \( W(y) \) также проходит через проверку имен.
   - Здесь происходит унификация: \( W(x2) \) с \( W(y) \).
   - Таблицы обновляются, добавляя новые значения.

8. **Доказанные атомы и правила**
   - Атом \( W(M1) \) добавляется в список доказанных атомов, а правило с номером 3 теперь доказано.

9. **Переход к текущей подцели C(W)**
   - Программа возвращается к начальной подцели \( C(W) \), но теперь список доказанных атомов расширен.
   - Процесс унификации повторяется для \( C(x) \) и \( C(W) \).

10. **Атом S(x, y, z)**
    - Программа пытается доказать атом \( S(x, y, z) \). Происходит несколько сравнений имен.
    - Так как ни одно имя не совпадает, атом становится новой подцелью.
    - Унификация успешно выполняется: \( S(W, x1, N) \), что подчеркивает, что программа обнаружила соответствие.

### Итог

Программа реализует процесс логического вывода, который включает проверку имен, создание подстановок и постоянное обогащение списка доказанных атомов и правил. В этом процессе встречается ряд атомов, которые либо уже доказаны, либо становятся новыми подцелями для дальнейшего вывода. Происходит также работа с таблицами подстановок и связей, что является важным элементом унификации в логических системах.
